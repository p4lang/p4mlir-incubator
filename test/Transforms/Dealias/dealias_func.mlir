// RUN: p4mlir-opt -p4hir-copyin-copyout-elimination < %s | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK: #[[$DIR_IN:.+]] = #p4hir<dir in>
// CHECK: #[[$DIR_INOUT:.+]] = #p4hir<dir inout>
// CHECK: #[[$DIR_OUT:.+]] = #p4hir<dir out>
!b1i = !p4hir.bit<1>
#in = #p4hir<dir in>
#inout = #p4hir<dir inout>
#out = #p4hir<dir out>
!S = !p4hir.struct<"S", x: !b1i>
!T = !p4hir.struct<"T", x: !b1i, y: !b1i>
module {
  // extern void f(inout bit x, in bit y);
  // extern bit g(inout bit z);
  // extern bit h(out bit zz);
  // 
  // struct S {
  //    bit x;
  //  }
  //
  //  struct T {
  //    bit x;
  //    bit y;
  //  }
  //
  //  extern void s(inout S s, inout bit x);
  //  extern void t(inout bit x, inout bit y);

  p4hir.func @f(!p4hir.ref<!b1i> {p4hir.dir = #inout, p4hir.param_name = "x"}, !b1i {p4hir.dir = #in, p4hir.param_name = "y"})
  p4hir.func @g(!p4hir.ref<!b1i> {p4hir.dir = #inout, p4hir.param_name = "z"}) -> !b1i
  p4hir.func @h(!p4hir.ref<!b1i> {p4hir.dir = #out, p4hir.param_name = "zz"}) -> !b1i
  p4hir.func @s(!p4hir.ref<!S> {p4hir.dir = #inout, p4hir.param_name = "s"}, !p4hir.ref<!b1i> {p4hir.dir = #inout, p4hir.param_name = "x"})
  p4hir.func @t(!p4hir.ref<!b1i> {p4hir.dir = #inout, p4hir.param_name = "x"}, !p4hir.ref<!b1i> {p4hir.dir = #inout, p4hir.param_name = "y"})

  // Check single out argument
  //  action test1() {
  //    bit a;
  //    h(a);
  //  }
// CHECK-LABEL:   p4hir.func action @test1() {
// CHECK:           %[[VAL_0:.*]] = p4hir.variable ["a"] : <!b1i>
// CHECK:           %[[VAL_1:.*]] = p4hir.scope {
// CHECK:             %[[VAL_2:.*]] = p4hir.call @h (%[[VAL_0]]) : (!p4hir.ref<!b1i>) -> !b1i
// CHECK:             p4hir.yield %[[VAL_2]] : !b1i
// CHECK:           } : !b1i
// CHECK:           p4hir.return
// CHECK:         }
  p4hir.func action @test1() {
    %a = p4hir.variable ["a"] : <!b1i>
    %0 = p4hir.scope {
      %zz_out_arg = p4hir.variable ["zz_out_arg"] : <!b1i>
      %call = p4hir.call @h (%zz_out_arg) : (!p4hir.ref<!b1i>) -> !b1i
      %val = p4hir.read %zz_out_arg : <!b1i>
      p4hir.assign %val, %a : <!b1i>
      p4hir.yield %call : !b1i
    } : !b1i
    p4hir.return
  }

// Check single in out argument
// action test2() {
//   bit a;
//   g(a);
// }
// CHECK-LABEL:   p4hir.func action @test2() {
// CHECK:           %[[VAL_0:.*]] = p4hir.variable ["a"] : <!b1i>
// CHECK:           %[[VAL_1:.*]] = p4hir.scope {
// CHECK:             %[[VAL_2:.*]] = p4hir.call @g (%[[VAL_0]]) : (!p4hir.ref<!b1i>) -> !b1i
// CHECK:             p4hir.yield %[[VAL_2]] : !b1i
// CHECK:           } : !b1i
// CHECK:           p4hir.return
// CHECK:         }
  p4hir.func action @test2() {
    %a = p4hir.variable ["a"] : <!b1i>
    %0 = p4hir.scope {
      %z_inout_arg = p4hir.variable ["z_inout_arg", init] : <!b1i>
      %val = p4hir.read %a : <!b1i>
      p4hir.assign %val, %z_inout_arg : <!b1i>
      %call = p4hir.call @g (%z_inout_arg) : (!p4hir.ref<!b1i>) -> !b1i
      %val_0 = p4hir.read %z_inout_arg : <!b1i>
      p4hir.assign %val_0, %a : <!b1i>
      p4hir.yield %call : !b1i
    } : !b1i
    p4hir.return
  }

  // Potential intervening write, can only dealias g() call as it could clobber `a`
  // action test3() {
  //   bit a;
  //   f(a, g(a));
  // }

// CHECK-LABEL:   p4hir.func action @test3() {
// CHECK:           %[[VAL_0:.*]] = p4hir.variable ["a"] : <!b1i>
// CHECK:           p4hir.scope {
// CHECK:             %[[VAL_1:.*]] = p4hir.variable ["x_inout_arg", init] : <!b1i>
// CHECK:             %[[VAL_2:.*]] = p4hir.read %[[VAL_0]] : <!b1i>
// CHECK:             p4hir.assign %[[VAL_2]], %[[VAL_1]] : <!b1i>
// CHECK:             %[[VAL_3:.*]] = p4hir.scope {
// CHECK:               %[[VAL_4:.*]] = p4hir.call @g (%[[VAL_0]]) : (!p4hir.ref<!b1i>) -> !b1i
// CHECK:               p4hir.yield %[[VAL_4]] : !b1i
// CHECK:             } : !b1i
// CHECK:             p4hir.call @f (%[[VAL_1]], %[[VAL_3]]) : (!p4hir.ref<!b1i>, !b1i) -> ()
// CHECK:             %[[VAL_5:.*]] = p4hir.read %[[VAL_1]] : <!b1i>
// CHECK:             p4hir.assign %[[VAL_5]], %[[VAL_0]] : <!b1i>
// CHECK:           }
// CHECK:           p4hir.return
// CHECK:         }
  p4hir.func action @test3() {
    %a = p4hir.variable ["a"] : <!b1i>
    p4hir.scope {
      %x_inout_arg = p4hir.variable ["x_inout_arg", init] : <!b1i>
      %val = p4hir.read %a : <!b1i>
      p4hir.assign %val, %x_inout_arg : <!b1i>
      %0 = p4hir.scope {
        %z_inout_arg = p4hir.variable ["z_inout_arg", init] : <!b1i>
        %val_1 = p4hir.read %a : <!b1i>
        p4hir.assign %val_1, %z_inout_arg : <!b1i>
        %call = p4hir.call @g (%z_inout_arg) : (!p4hir.ref<!b1i>) -> !b1i
        %val_2 = p4hir.read %z_inout_arg : <!b1i>
        p4hir.assign %val_2, %a : <!b1i>
        p4hir.yield %call : !b1i
      } : !b1i
      p4hir.call @f (%x_inout_arg, %0) : (!p4hir.ref<!b1i>, !b1i) -> ()
      %val_0 = p4hir.read %x_inout_arg : <!b1i>
      p4hir.assign %val_0, %a : <!b1i>
    }
    p4hir.return
  }

  // Another example of potential intervening write. Cannot dealias `a.x`
  // action test4() {
  //   S a; 
  //   s(a, a.x);
  // }
// CHECK-LABEL:   p4hir.func action @test4() {
// CHECK:           %[[VAL_0:.*]] = p4hir.variable ["a"] : <!S>
// CHECK:           p4hir.scope {
// CHECK:             %[[VAL_1:.*]] = p4hir.struct_extract_ref %[[VAL_0]]["x"] : <!S>
// CHECK:             %[[VAL_2:.*]] = p4hir.variable ["x_inout_arg", init] : <!b1i>
// CHECK:             %[[VAL_3:.*]] = p4hir.read %[[VAL_1]] : <!b1i>
// CHECK:             p4hir.assign %[[VAL_3]], %[[VAL_2]] : <!b1i>
// CHECK:             p4hir.call @s (%[[VAL_0]], %[[VAL_2]]) : (!p4hir.ref<!S>, !p4hir.ref<!b1i>) -> ()
// CHECK:             %[[VAL_4:.*]] = p4hir.read %[[VAL_2]] : <!b1i>
// CHECK:             p4hir.assign %[[VAL_4]], %[[VAL_1]] : <!b1i>
// CHECK:           }
// CHECK:           p4hir.return
// CHECK:         }
  p4hir.func action @test4() {
    %a = p4hir.variable ["a"] : <!S>
    p4hir.scope {
      %s_inout_arg = p4hir.variable ["s_inout_arg", init] : <!S>
      %val = p4hir.read %a : <!S>
      p4hir.assign %val, %s_inout_arg : <!S>
      %x_field_ref = p4hir.struct_extract_ref %a["x"] : <!S>
      %x_inout_arg = p4hir.variable ["x_inout_arg", init] : <!b1i>
      %val_0 = p4hir.read %x_field_ref : <!b1i>
      p4hir.assign %val_0, %x_inout_arg : <!b1i>
      p4hir.call @s (%s_inout_arg, %x_inout_arg) : (!p4hir.ref<!S>, !p4hir.ref<!b1i>) -> ()
      %val_1 = p4hir.read %s_inout_arg : <!S>
      p4hir.assign %val_1, %a : <!S>
      %val_2 = p4hir.read %x_inout_arg : <!b1i>
      p4hir.assign %val_2, %x_field_ref : <!b1i>
    }
    p4hir.return
  }

  // No aliasing, a.y is passed by value
  // action test5() {
  //   T a; 
  //   f(a.x, a.y);
  // }
// CHECK-LABEL:   p4hir.func action @test5() {
// CHECK:           %[[VAL_0:.*]] = p4hir.variable ["a"] : <!T>
// CHECK:           p4hir.scope {
// CHECK:             %[[VAL_1:.*]] = p4hir.struct_extract_ref %[[VAL_0]]["x"] : <!T>
// CHECK:             %[[VAL_2:.*]] = p4hir.read %[[VAL_0]] : <!T>
// CHECK:             %[[VAL_3:.*]] = p4hir.struct_extract %[[VAL_2]]["y"] : !T
// CHECK:             p4hir.call @f (%[[VAL_1]], %[[VAL_3]]) : (!p4hir.ref<!b1i>, !b1i) -> ()
// CHECK:           }
// CHECK:           p4hir.return
// CHECK:         }
  p4hir.func action @test5() {
    %a = p4hir.variable ["a"] : <!T>
    p4hir.scope {
      %x_field_ref = p4hir.struct_extract_ref %a["x"] : <!T>
      %x_inout_arg = p4hir.variable ["x_inout_arg", init] : <!b1i>
      %val = p4hir.read %x_field_ref : <!b1i>
      p4hir.assign %val, %x_inout_arg : <!b1i>
      %val_0 = p4hir.read %a : <!T>
      %y = p4hir.struct_extract %val_0["y"] : !T
      p4hir.call @f (%x_inout_arg, %y) : (!p4hir.ref<!b1i>, !b1i) -> ()
      %val_1 = p4hir.read %x_inout_arg : <!b1i>
      p4hir.assign %val_1, %x_field_ref : <!b1i>
    }
    p4hir.return
  }

  // We do not have field-sensititve AA (yet), currently we project field references
  // back to the original variable as a result we can only dealias one argument, second
  // one is conservatively assumed to "may alias"
  // action test6() {
  //   T a; 
  //   t(a.x, a.y);
  // }
// CHECK-LABEL:   p4hir.func action @test6() {
// CHECK:           %[[VAL_0:.*]] = p4hir.variable ["a"] : <!T>
// CHECK:           p4hir.scope {
// CHECK:             %[[VAL_1:.*]] = p4hir.struct_extract_ref %[[VAL_0]]["x"] : <!T>
// CHECK:             %[[VAL_2:.*]] = p4hir.struct_extract_ref %[[VAL_0]]["y"] : <!T>
// CHECK:             %[[VAL_3:.*]] = p4hir.variable ["y_inout_arg", init] : <!b1i>
// CHECK:             %[[VAL_4:.*]] = p4hir.read %[[VAL_2]] : <!b1i>
// CHECK:             p4hir.assign %[[VAL_4]], %[[VAL_3]] : <!b1i>
// CHECK:             p4hir.call @t (%[[VAL_1]], %[[VAL_3]]) : (!p4hir.ref<!b1i>, !p4hir.ref<!b1i>) -> ()
// CHECK:             %[[VAL_5:.*]] = p4hir.read %[[VAL_3]] : <!b1i>
// CHECK:             p4hir.assign %[[VAL_5]], %[[VAL_2]] : <!b1i>
// CHECK:           }
// CHECK:           p4hir.return
// CHECK:         }
  p4hir.func action @test6() {
    %a = p4hir.variable ["a"] : <!T>
    p4hir.scope {
      %x_field_ref = p4hir.struct_extract_ref %a["x"] : <!T>
      %x_inout_arg = p4hir.variable ["x_inout_arg", init] : <!b1i>
      %val = p4hir.read %x_field_ref : <!b1i>
      p4hir.assign %val, %x_inout_arg : <!b1i>
      %y_field_ref = p4hir.struct_extract_ref %a["y"] : <!T>
      %y_inout_arg = p4hir.variable ["y_inout_arg", init] : <!b1i>
      %val_0 = p4hir.read %y_field_ref : <!b1i>
      p4hir.assign %val_0, %y_inout_arg : <!b1i>
      p4hir.call @t (%x_inout_arg, %y_inout_arg) : (!p4hir.ref<!b1i>, !p4hir.ref<!b1i>) -> ()
      %val_1 = p4hir.read %x_inout_arg : <!b1i>
      p4hir.assign %val_1, %x_field_ref : <!b1i>
      %val_2 = p4hir.read %y_inout_arg : <!b1i>
      p4hir.assign %val_2, %y_field_ref : <!b1i>
    }
    p4hir.return
  }

  // Same as above: our AA is local one so does not know that incoming function arguments
  // cannot alias each other
  // action test7(inout bit x, inout bit y) {
  //   t(x, y);
  // }
// CHECK-LABEL:   p4hir.func action @test7(
// CHECK-SAME:      %[[ARG0:.*]]: !p4hir.ref<!b1i> {p4hir.dir = #[[$DIR_INOUT]], p4hir.param_name = "x"},
// CHECK-SAME:      %[[ARG1:.*]]: !p4hir.ref<!b1i> {p4hir.dir = #[[$DIR_INOUT]], p4hir.param_name = "y"}) {
// CHECK:           p4hir.scope {
// CHECK:             %[[VAL_0:.*]] = p4hir.variable ["y_inout_arg", init] : <!b1i>
// CHECK:             %[[VAL_1:.*]] = p4hir.read %[[ARG1]] : <!b1i>
// CHECK:             p4hir.assign %[[VAL_1]], %[[VAL_0]] : <!b1i>
// CHECK:             p4hir.call @t (%[[ARG0]], %[[VAL_0]]) : (!p4hir.ref<!b1i>, !p4hir.ref<!b1i>) -> ()
// CHECK:             %[[VAL_2:.*]] = p4hir.read %[[VAL_0]] : <!b1i>
// CHECK:             p4hir.assign %[[VAL_2]], %[[ARG1]] : <!b1i>
// CHECK:           }
// CHECK:           p4hir.return
// CHECK:         }
  p4hir.func action @test7(%arg0: !p4hir.ref<!b1i> {p4hir.dir = #inout, p4hir.param_name = "x"}, %arg1: !p4hir.ref<!b1i> {p4hir.dir = #inout, p4hir.param_name = "y"}) {
    p4hir.scope {
      %x_inout_arg = p4hir.variable ["x_inout_arg", init] : <!b1i>
      %val = p4hir.read %arg0 : <!b1i>
      p4hir.assign %val, %x_inout_arg : <!b1i>
      %y_inout_arg = p4hir.variable ["y_inout_arg", init] : <!b1i>
      %val_0 = p4hir.read %arg1 : <!b1i>
      p4hir.assign %val_0, %y_inout_arg : <!b1i>
      p4hir.call @t (%x_inout_arg, %y_inout_arg) : (!p4hir.ref<!b1i>, !p4hir.ref<!b1i>) -> ()
      %val_1 = p4hir.read %x_inout_arg : <!b1i>
      p4hir.assign %val_1, %arg0 : <!b1i>
      %val_2 = p4hir.read %y_inout_arg : <!b1i>
      p4hir.assign %val_2, %arg1 : <!b1i>
    }
    p4hir.return
  }
}
