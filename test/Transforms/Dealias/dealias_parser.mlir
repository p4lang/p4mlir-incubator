// RUN: p4mlir-opt -p4hir-copyin-copyout-elimination < %s | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

!b13i = !p4hir.bit<13>
!b16i = !p4hir.bit<16>
!b1i = !p4hir.bit<1>
!b2i = !p4hir.bit<2>
!b32i = !p4hir.bit<32>
!b48i = !p4hir.bit<48>
!b4i = !p4hir.bit<4>
!b6i = !p4hir.bit<6>
!b8i = !p4hir.bit<8>
!empty = !p4hir.struct<"empty">
!i10i = !p4hir.int<10>
!packet_in = !p4hir.extern<"packet_in">
!type_T = !p4hir.type_var<"T">
!validity_bit = !p4hir.validity.bit
#everything = #p4hir.universal_set : !p4hir.set<!p4hir.dontcare>
#false = #p4hir.bool<false> : !p4hir.bool
#in = #p4hir<dir in>
#out = #p4hir<dir out>
!Ethernet_h = !p4hir.header<"Ethernet_h", dstAddr: !b48i, srcAddr: !b48i, etherType: !b16i, __valid: !validity_bit>
!ipv4_t = !p4hir.header<"ipv4_t", version: !b4i, ihl: !b4i, dscp: !b6i, ecn: !b2i, totalLen: !b16i, identification: !b16i, flag_rsvd: !b1i, flag_noFrag: !b1i, flag_more: !b1i, fragOffset: !b13i, ttl: !b8i, protocol: !b8i, hdrChecksum: !b16i, srcAddr: !b32i, dstAddr: !b32i, __valid: !validity_bit>
#int1_i10i = #p4hir.int<1> : !i10i
#int2048_b16i = #p4hir.int<2048> : !b16i
#int23_b8i = #p4hir.int<23> : !b8i
#int2_i10i = #p4hir.int<2> : !i10i
#int4_b4i = #p4hir.int<4> : !b4i
#int6_b8i = #p4hir.int<6> : !b8i
!Parsed_packet = !p4hir.struct<"Parsed_packet", ethernet: !Ethernet_h, ipv4: !ipv4_t>
// CHECK: #[[$DIR_IN:.+]] = #p4hir<dir in>
// CHECK: #[[$DIR_OUT:.+]] = #p4hir<dir out>
module {
  p4hir.extern @packet_in {
    p4hir.overload_set @extract {
      p4hir.func @extract_0<!type_T>(!p4hir.ref<!type_T> {p4hir.dir = #out, p4hir.param_name = "hdr"})
      p4hir.func @extract_1<!type_T>(!p4hir.ref<!type_T> {p4hir.dir = #out, p4hir.param_name = "variableSizeHeader"}, !b32i {p4hir.dir = #in, p4hir.param_name = "variableFieldSizeInBits"})
    }
    p4hir.func @lookahead<!type_T>() -> !type_T
    p4hir.func @advance(!b32i {p4hir.dir = #in, p4hir.param_name = "sizeInBits"})
    p4hir.func @length() -> !b32i
  }

// Check dealiasing of method calls
// CHECK-LABEL:   p4hir.parser @parserI(
// CHECK-SAME:      %[[ARG0:.*]]: !packet_in {p4hir.dir = #p4hir<dir undir>, p4hir.param_name = "pkt"},
// CHECK-SAME:      %[[ARG1:.*]]: !p4hir.ref<!Parsed_packet> {p4hir.dir = #[[$DIR_OUT]], p4hir.param_name = "hdr"})() {
// CHECK:           p4hir.state @start {
// CHECK:             p4hir.scope {
// CHECK:               %[[VAL_5:.*]] = p4hir.struct_field_ref %[[ARG1]]["ethernet"] : <!Parsed_packet>
// CHECK:               p4hir.call_method @packet_in::@extract<[!Ethernet_h]> of %[[ARG0]] : !packet_in (%[[VAL_5]]) : (!p4hir.ref<!Ethernet_h>) -> ()
// CHECK:             }
// CHECK:           p4hir.state @parse_ipv4 {
// CHECK:             p4hir.scope {
// CHECK:               %[[VAL_9:.*]] = p4hir.struct_field_ref %[[ARG1]]["ipv4"] : <!Parsed_packet>
// CHECK:               p4hir.call_method @packet_in::@extract<[!ipv4_t]> of %[[ARG0]] : !packet_in (%[[VAL_9]]) : (!p4hir.ref<!ipv4_t>) -> ()
// CHECK:             }
  p4hir.parser @parserI(%arg0: !packet_in {p4hir.dir = #p4hir<dir undir>, p4hir.param_name = "pkt"}, %arg1: !p4hir.ref<!Parsed_packet> {p4hir.dir = #out, p4hir.param_name = "hdr"})() {
    p4hir.state @start {
      p4hir.scope {
        %ethernet_field_ref = p4hir.struct_field_ref %arg1["ethernet"] : <!Parsed_packet>
        %hdr_out_arg = p4hir.variable ["hdr_out_arg"] : <!Ethernet_h>
        p4hir.call_method @packet_in::@extract<[!Ethernet_h]> of %arg0 : !packet_in (%hdr_out_arg) : (!p4hir.ref<!Ethernet_h>) -> ()
        %val_0 = p4hir.read %hdr_out_arg : <!Ethernet_h>
        p4hir.assign %val_0, %ethernet_field_ref : <!Ethernet_h>
      }
      %val = p4hir.read %arg1 : <!Parsed_packet>
      %ethernet = p4hir.struct_extract %val["ethernet"] : !Parsed_packet
      %etherType = p4hir.struct_extract %ethernet["etherType"] : !Ethernet_h
      p4hir.transition_select %etherType : !b16i {
        p4hir.select_case {
          %c2048_b16i = p4hir.const #int2048_b16i
          %set = p4hir.set (%c2048_b16i) : !p4hir.set<!b16i>
          p4hir.yield %set : !p4hir.set<!b16i>
        } to @parserI::@parse_ipv4
        p4hir.select_case {
          %everything = p4hir.const #everything
          p4hir.yield %everything : !p4hir.set<!p4hir.dontcare>
        } to @parserI::@accept
      }
    }
    p4hir.state @parse_ipv4 {
      p4hir.scope {
        %ipv4_field_ref = p4hir.struct_field_ref %arg1["ipv4"] : <!Parsed_packet>
        %hdr_out_arg = p4hir.variable ["hdr_out_arg"] : <!ipv4_t>
        p4hir.call_method @packet_in::@extract<[!ipv4_t]> of %arg0 : !packet_in (%hdr_out_arg) : (!p4hir.ref<!ipv4_t>) -> ()
        %val_2 = p4hir.read %hdr_out_arg : <!ipv4_t>
        p4hir.assign %val_2, %ipv4_field_ref : <!ipv4_t>
      }
      %val = p4hir.read %arg1 : <!Parsed_packet>
      %ipv4 = p4hir.struct_extract %val["ipv4"] : !Parsed_packet
      %version = p4hir.struct_extract %ipv4["version"] : !ipv4_t
      %val_0 = p4hir.read %arg1 : <!Parsed_packet>
      %ipv4_1 = p4hir.struct_extract %val_0["ipv4"] : !Parsed_packet
      %protocol = p4hir.struct_extract %ipv4_1["protocol"] : !ipv4_t
      p4hir.transition_select %version, %protocol : !b4i, !b8i {
        p4hir.select_case {
          %c4_b4i = p4hir.const #int4_b4i
          %set = p4hir.set (%c4_b4i) : !p4hir.set<!b4i>
          %c6_b8i = p4hir.const #int6_b8i
          %set_2 = p4hir.set (%c6_b8i) : !p4hir.set<!b8i>
          p4hir.yield %set, %set_2 : !p4hir.set<!b4i>, !p4hir.set<!b8i>
        } to @parserI::@accept
        p4hir.select_case {
          %c4_b4i = p4hir.const #int4_b4i
          %set = p4hir.set (%c4_b4i) : !p4hir.set<!b4i>
          %c23_b8i = p4hir.const #int23_b8i
          %set_2 = p4hir.set (%c23_b8i) : !p4hir.set<!b8i>
          p4hir.yield %set, %set_2 : !p4hir.set<!b4i>, !p4hir.set<!b8i>
        } to @parserI::@accept
        p4hir.select_case {
          %everything = p4hir.const #everything
          p4hir.yield %everything : !p4hir.set<!p4hir.dontcare>
        } to @parserI::@accept
      }
    }
    p4hir.state @accept {
      p4hir.parser_accept
    }
    p4hir.state @reject {
      p4hir.parser_reject
    }
    p4hir.transition to @parserI::@start
  }
  p4hir.parser @subparser3(%arg0: !p4hir.ref<!i10i> {p4hir.dir = #p4hir<dir inout>, p4hir.param_name = "s"}, %arg1: !p4hir.ref<!p4hir.bool> {p4hir.dir = #out, p4hir.param_name = "matched"})() {
    p4hir.state @start {
      p4hir.transition to @subparser3::@accept
    }
    p4hir.state @accept {
      p4hir.parser_accept
    }
    p4hir.state @reject {
      p4hir.parser_reject
    }
    p4hir.transition to @subparser3::@start
  }
  p4hir.parser @subparser2(%arg0: !p4hir.ref<!p4hir.bool> {p4hir.dir = #out, p4hir.param_name = "matched"})() {
    p4hir.state @start {
      p4hir.transition to @subparser2::@accept
    }
    p4hir.state @accept {
      p4hir.parser_accept
    }
    p4hir.state @reject {
      p4hir.parser_reject
    }
    p4hir.transition to @subparser2::@start
  }
  p4hir.parser @subparser1(%arg0: !p4hir.ref<!i10i> {p4hir.dir = #p4hir<dir inout>, p4hir.param_name = "s"})() {
    p4hir.state @start {
      p4hir.transition to @subparser1::@accept
    }
    p4hir.state @accept {
      p4hir.parser_accept
    }
    p4hir.state @reject {
      p4hir.parser_reject
    }
    p4hir.transition to @subparser1::@start
  }

// Check dealiasing of subparser applies
// CHECK-LABEL:   p4hir.parser @p(
// CHECK-SAME:                    %[[ARG0:.*]]: !empty {p4hir.dir = #[[$DIR_IN]], p4hir.param_name = "e"},
// CHECK-SAME:                    %[[ARG1:.*]]: !i10i {p4hir.dir = #[[$DIR_IN]], p4hir.param_name = "sinit"})() {
// CHECK:           %[[VAL_3:.*]] = p4hir.variable ["s", init] : <!i10i>
// CHECK:           p4hir.assign %[[ARG1]], %[[VAL_3]] : <!i10i>
// CHECK:           p4hir.instantiate @subparser1 () as @sp1
// CHECK:           p4hir.instantiate @subparser2 () as @sp2
// CHECK:           p4hir.instantiate @subparser3 () as @sp3
// CHECK:           p4hir.state @start {
// CHECK:             p4hir.assign %{{.*}}, %[[VAL_3]] : <!i10i>
// CHECK:             p4hir.transition to @p::@next
// CHECK:           }
// CHECK:           p4hir.state @next {
// CHECK:             p4hir.assign %{{.*}}, %[[VAL_3]] : <!i10i>
// CHECK:             %[[VAL_4:.*]] = p4hir.variable ["matched", init] : <!p4hir.bool>
// CHECK:             p4hir.assign %{{.*}}, %[[VAL_4]] : <!p4hir.bool>
// CHECK:             p4hir.scope {
// CHECK:               p4hir.apply @p::@sp1(%[[VAL_3]]) : (!p4hir.ref<!i10i>) -> ()
// CHECK:             }
// CHECK:             p4hir.scope {
// CHECK:               p4hir.apply @p::@sp2(%[[VAL_4]]) : (!p4hir.ref<!p4hir.bool>) -> ()
// CHECK:             }
// CHECK:             p4hir.scope {
// CHECK:               p4hir.apply @p::@sp3(%[[VAL_3]], %[[VAL_4]]) : (!p4hir.ref<!i10i>, !p4hir.ref<!p4hir.bool>) -> ()
// CHECK:             }
  p4hir.parser @p(%arg0: !empty {p4hir.dir = #in, p4hir.param_name = "e"}, %arg1: !i10i {p4hir.dir = #in, p4hir.param_name = "sinit"})() {
    %s = p4hir.variable ["s", init] : <!i10i>
    p4hir.assign %arg1, %s : <!i10i>
    p4hir.instantiate @subparser1 () as @sp1
    p4hir.instantiate @subparser2 () as @sp2
    p4hir.instantiate @subparser3 () as @sp3
    p4hir.state @start {
      %c1_i10i = p4hir.const #int1_i10i
      %cast = p4hir.cast(%c1_i10i : !i10i) : !i10i
      p4hir.assign %cast, %s : <!i10i>
      p4hir.transition to @p::@next
    }
    p4hir.state @next {
      %c2_i10i = p4hir.const #int2_i10i
      %cast = p4hir.cast(%c2_i10i : !i10i) : !i10i
      p4hir.assign %cast, %s : <!i10i>
      %false = p4hir.const #false
      %matched = p4hir.variable ["matched", init] : <!p4hir.bool>
      p4hir.assign %false, %matched : <!p4hir.bool>
      p4hir.scope {
        %s_inout_arg = p4hir.variable ["s_inout_arg", init] : <!i10i>
        %val = p4hir.read %s : <!i10i>
        p4hir.assign %val, %s_inout_arg : <!i10i>
        p4hir.apply @p::@sp1(%s_inout_arg) : (!p4hir.ref<!i10i>) -> ()
        %val_0 = p4hir.read %s_inout_arg : <!i10i>
        p4hir.assign %val_0, %s : <!i10i>
      }
      p4hir.scope {
        %matched_out_arg = p4hir.variable ["matched_out_arg"] : <!p4hir.bool>
        p4hir.apply @p::@sp2(%matched_out_arg) : (!p4hir.ref<!p4hir.bool>) -> ()
        %val = p4hir.read %matched_out_arg : <!p4hir.bool>
        p4hir.assign %val, %matched : <!p4hir.bool>
      }
      p4hir.scope {
        %s_inout_arg = p4hir.variable ["s_inout_arg", init] : <!i10i>
        %val = p4hir.read %s : <!i10i>
        p4hir.assign %val, %s_inout_arg : <!i10i>
        %matched_out_arg = p4hir.variable ["matched_out_arg"] : <!p4hir.bool>
        p4hir.apply @p::@sp3(%s_inout_arg, %matched_out_arg) : (!p4hir.ref<!i10i>, !p4hir.ref<!p4hir.bool>) -> ()
        %val_0 = p4hir.read %s_inout_arg : <!i10i>
        p4hir.assign %val_0, %s : <!i10i>
        %val_1 = p4hir.read %matched_out_arg : <!p4hir.bool>
        p4hir.assign %val_1, %matched : <!p4hir.bool>
      }
      p4hir.transition to @p::@accept
    }
    p4hir.state @accept {
      p4hir.parser_accept
    }
    p4hir.state @reject {
      p4hir.parser_reject
    }
    p4hir.transition to @p::@start
  }
}
